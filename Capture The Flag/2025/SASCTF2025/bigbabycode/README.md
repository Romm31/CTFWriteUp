# Bigbabycode - SASCTF 2025

**FLAG:** `SAS{y0u_d0nt_r3ally_n33d_S_perm_t0_d3c0d3_Mc_3l1ec3_w1th_H4mm1ng_c0d3s}'

**Category: Cryptography**
--------------------------------------------------------------------------------
## Challenge Description
--------------------------------------------------------------------------------

> They whisper I need (S, perm) to spread the secret round' (bam, bam). That's not straight stuff, my man ain't doin it (for real).
> (Challenge also provided: task.py, alice_pub.npy, output.txt)

This challenge presented a McEliece-like cryptosystem. The goal was to decrypt the flag given the encryption script (`task.py`), the server's public key (`alice_pub.npy`), and the encrypted flag (`output.txt`).

--------------------------------------------------------------------------------
## Core Vulnerability: Low Error Rate (t=1)
--------------------------------------------------------------------------------

The encryption process (`task.py`) revealed the following:
* It uses a standard `(63,57)` Hamming code as the underlying code (generated by `G_h`). This code can correct 1 error.
* This `G_h` is then disguised using a random scrambling matrix `S` and a random column permutation `perm` to create the public key `G_pub`.
* **Crucially, during encryption, exactly one bit error (`t=1`) is intentionally introduced into each 63-bit block of the codeword `m @ G_pub`.**

While recovering the secret components `S` and `perm` from `G_pub` is the hard problem McEliece relies on, the fact that only **one error** is introduced per block makes the system vulnerable to a much simpler attack. We don't need `S` or `perm` at all!

--------------------------------------------------------------------------------
## Decoding Strategy: Guessing the Error
--------------------------------------------------------------------------------

Since each 63-bit ciphertext block `c` is just one bit different from a true codeword `m @ G_pub`, we can find the original message by:

1.  **Iterating Through Error Positions**: For each of the `N=63` possible bit positions in a received ciphertext block `c`:
    * Temporarily flip that bit. Let this new block be `c_candidate`.
    * Assume `c_candidate` is now the true (error-free) codeword.
2.  **Solving for the Message**: Try to find the original `K=57` bit message `m_candidate` that would produce this `c_candidate`. This means solving the equation `m_candidate @ G_pub = c_candidate` (all operations in GF(2)).
    * **Method**:
        * From `G_pub` (a 57x63 matrix), select 57 linearly independent columns. These columns form a 57x57 invertible matrix, let's call it `G_pub_sq`. Note the indices of these columns (`basis_indices`).
        * Pre-calculate the inverse of this square matrix: `G_pub_sq_inv = inv(G_pub_sq) mod 2`. This is a one-time setup. (The `solver.py` uses the `sympy` library for this).
        * For the current `c_candidate`, take the bits corresponding to `basis_indices` to get `c_candidate_sq`.
        * Calculate the potential message: `m_candidate = (c_candidate_sq @ G_pub_sq_inv) % 2`.
3.  **Verification**: Check if the calculated `m_candidate` is correct. Re-encode it: `test_codeword = (m_candidate @ G_pub) % 2`.
    * If `test_codeword` is identical to `c_candidate`, we have found the correct error position and the correct `m_candidate` for this block.
4.  **Handling Ciphertext Length**:
    * The hex string in `output.txt` is 158 characters long. This actually represents `10 * 63 = 630` bits of data, not `158 * 4 = 632` bits. The most significant `632 - 630 = 2` bits from a naive `len(hex)*4` conversion are padding and should be ignored. The `solver.py` correctly parses 630 bits.
    * These 630 bits are then split into ten 63-bit ciphertext blocks.
5.  **Reconstructing the Full Message**:
    * Concatenate all ten 57-bit decoded message blocks.
    * The original message was padded by appending a '1' bit, then '0's to make its length a multiple of `K=57`. Reverse this by finding the last '1' in the concatenated stream and taking all bits before it.
    * Convert the final unpadded bitstream from binary to ASCII text to get the flag.

This method works because the Hamming code used is guaranteed to correct a single error, and we know exactly one error was introduced.

--------------------------------------------------------------------------------
## Solver Script: `solver.py`
--------------------------------------------------------------------------------

The Python script `solver.py` located in this repository automates the entire decoding process described above.

**To run the solver:**

1.  **Ensure Dependencies are Installed**:
    The script requires the `numpy` and `sympy` Python libraries. If you don't have them, install them using pip:
    ```bash
    pip install numpy sympy
    ```
2.  **Place Required Files in the Same Directory**:
    Make sure the following files (provided by the CTF) are in the same directory as `solver.py`:
    * `alice_pub.npy` (the public key)
    * `output.txt` (the encrypted flag hex string - though the script has it hardcoded, it's good practice)
3.  **Execute the Script**:
    Open your terminal or command prompt, navigate to the directory containing the files, and run:
    ```bash
    python3 solver.py
    ```
    (Or `python solver.py` if `python3` is not your default Python 3 interpreter).

The script will:
* Load `alice_pub.npy`.
* Precompute the necessary matrix inverse from `G_pub`.
* Parse the hardcoded hex ciphertext from `output.txt` into 630 bits and then into 63-bit blocks.
* Decode each block by trying all single-bit error corrections.
* Unpad the concatenated result.
* Print the final decrypted flag to the console.

--------------------------------------------------------------------------------
## Files in this Repository
--------------------------------------------------------------------------------

* **README.txt** (This file)
* **solver.py**: The Python script to solve the challenge.
* **task.py**: The original challenge script provided by the CTF (for reference).
* **alice_pub.npy**: The public key file provided by the CTF.
* **output.txt**: The encrypted flag file provided by the CTF.
